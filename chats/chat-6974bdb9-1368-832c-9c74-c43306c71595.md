---

## APPEND 2026-02-16T15:32:03.913Z
- Source: https://chatgpt.com/c/6974bdb9-1368-832c-9c74-c43306c71595

# ChatGPT Snapshot
- URL: https://chatgpt.com/c/6974bdb9-1368-832c-9c74-c43306c71595
- Title: Integracao TIAS ATSC VendorBridge
- CapturedAt: 2026-02-16T15:32:03.613Z

## USER
astrotv-aidl-src-v1.3.zip
Zip Archive
astrotv-aidl-src-hisense-v1.4.zip
Zip Archive
VendorBridge.java
File
SessionHolder.java
File
TvIAppSessionImpl.java
File
TvIAppServiceImpl.java
File
VendorBridgeFactory.java
File
TiasVendorBridge.java
File
integracao TIAS + LiveTv + AIDL-TIAS + AIDL-ATSC
 . tenho um projeto q funciona para o TIAS + LiveTv +AIDL (VendorFacade e AstrotvAllInterface), tenho outro que eh um client ATSC com novo decoder proprietario. agora estamos trabalhando em um novo projeto, merge de ambos anteriores com a Hisense. Ainda nao temos plataforma com o novo AIDL pro ATSC entao tenho q continuar o desenvolvimento usando os AIDLs antigos, das plataformas q funcionam. 
. com isso criamos um flavor tias e um atsc. nos flavors foram criados a implementacao do VendorBridge e a factory 
. no main foram criados o NoopVendoBridge, a interface e adptacoes do SesseionHolder - os Stubs das interfaces nem sempre sao inicializadas antes do Tias Service, e um depende do outro pra determidas operacoes; 
. vou reenviar, pois devem ter expirados: 
1. astrotv-aidl-src-hisense-v1.4.zip --> aidls para ATSC hisense 
2. astrotv-aidl-src-v1.3.zip --> aidls do projeto TIAS (atencao, pois o VendorFacade e AstrotvAllInterface possuem o mesmo nome e mesmo pacote) 
3. arquivos .java com as mudancas feitas ontem ontem estavamos discutindo a implementacao do vendorBridge com o setVendorFacade, quem ficaria controlando isso, se ficaria dentro do SessionHolder ou do vendorBridge

ontem, na outra task, estavamos discutindo a implementacao do vendorBridge com o setVendorFacade, quem ficaria controlando isso, se ficaria dentro do SessionHolder ou do vendorBridge.
como o vendorBridge precisa existir antes de saber quem eh o facade q esta em uso, isso me gerou duvidas e ao tentar retomar a task anterior, o historico se perdeu, entao abri essa  nova task

## USER
no TiasVendorBridge fiz a remocao do controle do vendorfacade ai ficaou assim:

...
    private IVendorFacade mVendorFacade;

    @Override
    public void setVendorFacade(IVendorFacade facade) {
        mVendorFacade = facade;
    }

    //----------------------------------------------------------------------------------------------
    @Override
    public boolean isAlive() {
        return mVendorFacade != null;
    }

    @Override
    public void close() {
        mVendorFacade = null;
        VendorBridge.super.close();
    }

    @Override
    public String getSerialNumber() {
        if (isAlive()) {
            try {
                return mVendorFacade.getSerialNumber();
            } catch (RemoteException e) {
                Log.e(TAG, "Error on facade method", e);
            }
        }
        return VendorBridge.super.getSerialNumber();
    }
...

demais funcoes seguem o mesmo principio

## USER
SessionHolder.java
File
VendorBridge.java
File
- o DeadObject ja esta sendo tratado no sessionHolder
- no VendorBridge, ainda tem um problema com os AIDLs:
 1. o TransportStream eh um Parcel que so existe no AIDL do TIAS, nao tem no ATSC
 2. os metodos de resquet* para ATSC, estao incompletos, assim como fizemos no response (SessionHolder#on*Data) tmb devemos fazer com os request

## USER
- sobre a assinaturas dos metodos resquest, de onde vc pegou os parametros, pois estao diferentes do AIDL

- sobre a adicao dos metodos request no sessionHolder, nao seria melhor fazer um withVendorResult(...) tipo o withSessionResult?

## USER
oi vc consegue recuperar o ponto de validacao desse historico, com a referencia de "validacao do sessionHoder e renomeacao para SessionOrchestrator", com a centraliza o roteamento para a Session TIAS ativa (sem espalhar referências fortes de Session pela base de código, reduzindo risco de leak)?

## USER
esse historico nao poderia ser como uma FIFO? pois ele so mantem a primeira parte da task, toda evolucao que fizemos, acaba se perdendo.
eh q gostaria de comecar efetivamente com o merge do projeto da TV3.0, visto q a parte de "arrumar a casa" ja esta validada

## USER
ok, mas pra garantir que vc esta com a ultima versao vou transfereir novamente as classes e o aidl.
porem vc pode remover todas as referencias de fontes anteriores, pra liberar espaco e nao gerar conflito com o que vou enviar em seguida?

## USER
hisense-20260126.zip
Zip Archive
astrotv-aidl-src-v1.3.zip
Zip Archive
VendorBridge.java
File
SessionOrchestrator.java
File
AtscVendorBridge.java
File
VendorBridgeFactory.java
File
AstrotvInterfaceImpl.java
File
TvIAppServiceImpl.java
File
TvIAppSessionImpl.java
File

## USER
esses sao os arquivos principais, ja validado com o LiveTv sem o AIDL ATSC, apenas com o AIDL TIAS

## USER
No `VendorBridge` ainda existem APIs TIAS com `TransportStream` (tipo TIAS-only).

pode ignorar, como na versao ATSC essa classe nao tera uso, eu apenas crie a classe dentro do flavor ATSC com os mesmos campos q o parcelable do flavors TIAS

@Keep
public final class TransportStream {
    public int     privateId;
    public int     tsId;
    public int     networkId;
    public int     channelNumber;

    public TransportStream(){
    }
}

## USER
"1) Garanta que o TransportStream do flavor ATSC não conflita com o do TIAS"
sim, o TransportStream do TIAS com o parcelable, esta no flavor do TIAS

"2) Marcar com @Keep é ok, mas não é necessário"
ok, ja removido

"4) Atenção: VendorBridgeFactory deve ser por flavor"
sim, esta por flavors, nao mandei nos anexos pois tem o mesmo nome, e o importande daqui pra frente eh a parte do ATSC

## USER
tenho o projeto commitado que build em uma maquina, ao fazer o clone em outra maquina, estou tendo um problema com o uso do artefato errado.
- uso uma versao modificado do exoplayer (media3) ai ao usar a referencia para 
`
    RunnableFutureTask<@NullableType ChunkIndex, IOException> runnable =
        new RunnableFutureTask<@NullableType ChunkIndex, IOException>() {
          @Override
          protected @NullableType ChunkIndex doWork() throws IOException {
            return DashUtil.loadChunkIndex(dataSource, trackType, representation);
          }
        };
    @Nullable ChunkIndex seekMap = execute(runnable, removing);
// o erro aponta para o "runnable"
`
ele acaba apontado para a lib oficial e nao para o modulo modificado q esta no projeto

/home/mirakulo/android/tv3.0/astrotv-refactory-wpe/android/astrotv-service/src/tv30/java/com/mirakulo/tv30/dash/offline/DashDownloader.java:262: error: method execute in class SegmentDownloader<M> cannot be applied to given types;
    @Nullable ChunkIndex seekMap = execute(runnable, removing);
                                   ^
Ask Gemini

## USER
o falvor estava errado, por alguma razao ele nao acatou a opcao "isDefault = true" no flavor q deveria ser o padrao

## USER
1) Defina explicitamente as flavorDimensions e ordene

no meu caso eu tb coloquei explicitamente o "isDefault = false" nos outros flavors
ex:
flavorDimensions "platform"
productFlavors {
  tias {
    dimension "platform"
    isDefault = true
...
  }
  atsc {
    dimension "platform"
    isDefault = true
...
  }
}

## USER
foi copy/past errado, por flavor so tem 1 com true e os outros como false, mas tem explicitamente o false

        tv30 {
            dimension "project_target"
            isDefault = true
            applicationIdSuffix ".tias"
            buildConfigField "boolean", "AD_REQUEST_UNSUPPORTED", "false" // if true, use fallback
            buildConfigField "boolean", "AD_REQUEST_TV30", "true" // if true, use view created by tv30
        }
        tias {
            dimension "project_target"
            isDefault = false
            applicationIdSuffix ".tias"
            buildConfigField "boolean", "AD_REQUEST_UNSUPPORTED", "true" // if true, use fallback
            buildConfigField "boolean", "AD_REQUEST_TV30", "false" // if true, use view created by tv30
        }
        tif {
            dimension "project_target"
            isDefault = false
            applicationIdSuffix ".service"
            buildConfigField "boolean", "AD_REQUEST_UNSUPPORTED", "true" // if true, use fallback
            buildConfigField "boolean", "AD_REQUEST_TV30", "false" // if true, use view created by tv30
        }

## USER
o .idea/ nao eh commitado nos projeto, apenas o gradle/

## USER
no meu aidl, eu tenho esse tratamento de handle, porem esta dando erro ao re-submeter uma msg.


public final class ServiceHandler extends Handler {
        public static final int MSG_TYPE_gingaWebServicesRegistry_setEventCallback=26;

        public ServiceHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(@NonNull Message msg) {
            // Normally we would do some work here, like download a file.
            try {
                if (LOG_VERBOSE) Log.v(TAG, "[ServiceHandler] IN");

                if(!SessionOrchestrator.getInstance().isMiddlewareRunning()) {
                    Log.d(TAG, "[ServiceHandler] waiting for start TIAS service. what="+msg.what);
                    removeMessages(msg.what);
                    sendMessageDelayed(msg,TIME_TO_RETRY_CALLBACK); //try again after 1 sec
                } else {
                    if (LOG_VERBOSE) Log.v(TAG, "[ServiceHandler] calling event enqueued: " + msg.what
                            + ", value="+msg.obj);
                    if (msg.what == MSG_TYPE_gingaWebServicesRegistry_setEventCallback) {
                        if (MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback(
                                (IGingaWebServicesRegistryEventCallback) msg.obj) == 0) {
                            Log.w(TAG, "[ServiceHandler] Error to register callback to web service");
                        }
                    } else {
                        if (LOG_VERBOSE)
                            Log.w(TAG, "[ServiceHandler] Unexpected value: " + msg.what);
                        super.handleMessage(msg);
                    }
                }
            } catch (IndexOutOfBoundsException e) {
                Log.e(TAG, "[ServiceHandler] Error: " + e);
            } catch (Exception e) {
                Log.e(TAG, "[ServiceHandler] Error: ", e);
            } finally {
                if (LOG_VERBOSE) Log.v(TAG, "[ServiceHandler] OUT");
            }
        }
    }

segue o erro:

10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: [ServiceHandler] Error: 
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: java.lang.IllegalStateException: { when=-1ms what=26 obj=com.mirakulo.astrotv.IGingaWebServicesRegistryEventCallback$Stub$Proxy@9507cb1 target=com.mirakulo.service.AstrotvInterfaceImpl$ServiceHandler } This message is already in use.
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.MessageQueue.enqueueMessage(MessageQueue.java:556)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.Handler.enqueueMessage(Handler.java:786)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.Handler.sendMessageAtTime(Handler.java:735)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.Handler.sendMessageDelayed(Handler.java:705)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at com.mirakulo.service.AstrotvInterfaceImpl$ServiceHandler.handleMessage(AstrotvInterfaceImpl.java:266)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.Handler.dispatchMessage(Handler.java:106)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.Looper.loopOnce(Looper.java:205)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.os.Looper.loop(Looper.java:294)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at android.app.ActivityThread.main(ActivityThread.java:8177)
10-06 10:55:52.358  4758  4758 E MIRAKULO_AstrotvInterfaceImpl: 	at java.lang.reflect.Method.invoke(Native Method)

## USER
BroadcastInfoRequest.java
File
SignalingDataRequest.java
File
tenho um AIDL onde faço o request do signalingData, onde passo um array. porem a classe eh derivada de outra classe base.
- metodo do request no aidl:
    void requestSignalingData(in SignalingDataRequest req);
    void removeSignalingDataRequest(int requestId);

- seque os metodos base e do request:
- esta correto a implementacao do SignalingDataRequest?
- qual seria o motivo do fabricante receber o array vazio?
- tem alguma forma de debugar a serializacao?

## USER
a minha chamada esta assim:
                SessionOrchestrator.getInstance().signalingRequest(
                        BroadcastInfoRequest.REQUEST_OPTION_AUTO_UPDATE,
                        -1, //whole groups
                        new ArrayList<>(List.of(
                                SignalingDataRequest.SIGNALING_METADATA_HELD,
                                SignalingDataRequest.SIGNALING_METADATA_SLT))
                );
que chama:
    int signalingRequest(int option, int group,
                         @NonNull List<String> signalingDataTypes) {
        return withVendorResult(vb -> vb.signalingRequest(option, group, signalingDataTypes), -1);
    }

e por sua vez:
    public int signalingRequest(int option, int group, @NonNull List<String> signalingDataTypes) {
        if (isAlive()) {
            try {
                final int id = mRequestId.getAndIncrement();
                mVendorFacade.requestSignalingData(new SignalingDataRequest(id, option, group, signalingDataTypes));
                return id;
            } catch (RemoteException e) {
                Log.e(TAG, "Error on facade method", e);
            }
        }
        return VendorBridge.super.signalingRequest(option, group, signalingDataTypes);
    }

## USER
o probrema era q estava usando a classe oficial BroadcastInfoRequest do google, e como eu tive q criar uma igual, pois ainda nao esta disponivel no sdk, ele nao soube serializar o meu request.
mudei o nome do pacote no import e funcionou.

agora eu percebi um erro no meu jni ao tentar registrar uma callback vindo do livetv:
AstroWebServices.cpp:133 astroWebServicesRegistry_setEventCallback ::ERROR:: Couldn't get AuthorizationRegistry

essa linha eh o final da funcao abaixo:
extern "C" void AstroWebServices_priv_initJniBindings(JNIEnv *env) {
    LOGI("[JNI] [AstroWebServices_priv_initJniBindings] IN");
    int status = env->GetJavaVM(&g_jvm);
    if(status != 0) {
        LOGE("[%s] Couldn't get JavaVM pointer", __FUNCTION__);
        return;
    }
    jclass local_class = env->FindClass("com/mirakulo/astrotv/IGingaWebServicesRegistryEventCallback");
    if (!local_class) {
        LOGE("[%s] Couldn't find IGingaWebServicesRegistryEventCallback", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_IGingaWebServicesCb_class = (jclass)env->NewGlobalRef(local_class);
    if (!g_IGingaWebServicesCb_class) {
        LOGE("[%s] Couldn't allocated IGingaWebServicesRegistryEventCallback", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_IGingaWebServicesCb_notify = (jmethodID)env->GetMethodID(g_IGingaWebServicesCb_class, "callback", "(ILcom/mirakulo/astrotv/GingaWebServicesClientData;)V");
    
    local_class = env->FindClass("com/mirakulo/astrotv/GingaWebServicesClientData");
    if (!local_class) {
        LOGE("[%s] Couldn't find GingaWebServicesClientData", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_class = (jclass)env->NewGlobalRef(local_class);
    if (!g_IGingaWebServicesCb_class) {
        LOGE("[%s] Couldn't allocated GingaWebServicesClientData", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_constructor = (jmethodID)env->GetMethodID(g_IGingaWebServicesCb_class, "<init>", "()V");
    g_WebServicesClientData_handle = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "handle", "I");
    g_WebServicesClientData_name = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "name", "Ljava/lang/String;");
    g_WebServicesClientData_status = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "status", "I");
    LOGI("[JNI] [AstroWebServices_priv_initJniBindings] OUT");
}

## USER
entao, acho q tem mais erros nesse codigo, pq o "g_IGingaWebServicesCb_class" nao esta sendo criado/alocado em lugar algum.

quanto ao tratamento das exception, nao tratei os fields, pq se chegar ali, eh pq existe a classe. lembrando q uso multiplas implementacoes do AIDL e algumas nao tem a definicao dessa classe

a interface esta definida assim, sem ser um parcelable:

interface IGingaWebServicesRegistryEventCallback {
    /**
     * @brief List of events notified from AstroTV to the platform.
     */
     const int GINGA_WEB_SERVICES_REGISTRY_EVENT_ADDED = 0;     /**< A new client has just been added to AstroTV's internal registry */
     const int GINGA_WEB_SERVICES_REGISTRY_EVENT_UPDATED = 1;   /**< The status/information of an existing client has been changed */
     const int GINGA_WEB_SERVICES_REGISTRY_EVENT_REMOVED = 2;   /**< The entry for an existing client has just been removed from the registry */

    /**
     * @brief Type of the callback function to be provided by the platform and
     * registered through GingaWebServicesRegistry_setEventCallback().
     *
     * This function will be called by AstroTV to notify the platform about all
     * events related to this API.
     *
     * @param [in] event Code of the event being notified (@see GINGA_WEB_SERVICES_REGISTRY_EVENT_*)
     * @param [in] handle Unique identifier for the client affected in this event.
     * @param [in] pData Pointer to an GingaWebServicesClientData structure with
     * the updated client data (NULL will be used when it's not meaningful).
     * The memory pointed by pData is allocated by AstroTV using malloc()/calloc()
     * and it is only used as a buffer to transfer the application's attributes
     * to the callback. AstroTV will not change this buffer and it is a platform
     * responsibility to free its memory.
     * Every time the callback function is called, a new memory buffer is allocated
     * and the platform can decide to copy the data and free the memory, or to keep
     * the buffer.
     */
//    typedef void (*fGingaWebServicesRegistryEventCallback)
//    	(int event, int handle, GingaWebServicesClientData *pData);

    void callback( in int event, in GingaWebServicesClientData pData);
}

## USER
acho q nesse trecho q passei deveria ser tudo com o g_IGingaWebServicesCb_class mesmo, pois parece q o data eh pra obter os campos, pq aqui eh q esta sendo inicializado

static jobject internal_getClientDataJObject(JNIEnv *env, astroWebServicesClientHandle handle,
                                             sAstroWebServicesClientData *pData) {
    LOGI("[internal_getClientDataJObject] IN - handle=%d, pData=%p", (int)handle, pData);
    if (pData == NULL) {
        LOGE("[internal_getClientDataJObject] data is NULL");
        return NULL;
    };
    jobject jClientData = env->NewObject(g_WebServicesClientData_class, g_WebServicesClientData_constructor);
    env->SetIntField(jClientData, g_WebServicesClientData_handle, (jint)pData->handle);
    jstring jName = env->NewStringUTF(pData->name);
    env->SetObjectField(jClientData, g_WebServicesClientData_name, jName); // TODO Release Chars? Mem. Leak?
    env->SetIntField(jClientData, g_WebServicesClientData_status, (jint)pData->status);
    LOGI("[internal_getClientDataJObject] OUT - return %p", jClientData);
    return jClientData;
}

## USER
vou colocar aqui o jni ja alterado, mas ainda esta faltando a liberacao dos recursos alocados em caso de erro, ou mesmo quando recebe uma nova callback

#include <jni.h>

#include <AstroWebServices.h>
#include <android/log.h>

#define  LOG_TAG    "MIRAKULO"
#if 1 /* 1 to enable logs */
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#else
#define LOGI(...)
#define LOGE(...)   __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#endif

// instance of IGingaWebServicesCallback registered via
// MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback()
static JavaVM *g_jvm = NULL;

static jclass g_IGingaWebServicesCb_class = NULL;
static jobject g_IGingaWebServicesCb_instance = NULL;
static jmethodID g_IGingaWebServicesCb_notify = NULL;

static jclass g_WebServicesClientData_class;
static jmethodID g_WebServicesClientData_constructor;
static jfieldID g_WebServicesClientData_handle;
static jfieldID g_WebServicesClientData_name;
static jfieldID g_WebServicesClientData_status;

static jobject internal_getClientDataJObject(JNIEnv *env, astroWebServicesClientHandle handle,
                                             sAstroWebServicesClientData *pData) {
    LOGI("[internal_getClientDataJObject] IN - handle=%d, pData=%p", (int)handle, pData);
    if (pData == NULL) {
        LOGE("[internal_getClientDataJObject] data is NULL");
        return NULL;
    };
    jobject jClientData = env->NewObject(g_WebServicesClientData_class, g_WebServicesClientData_constructor);
    env->SetIntField(jClientData, g_WebServicesClientData_handle, (jint)pData->handle);
    jstring jName = env->NewStringUTF(pData->name);
    env->SetObjectField(jClientData, g_WebServicesClientData_name, jName); // TODO Release Chars? Mem. Leak?
    env->SetIntField(jClientData, g_WebServicesClientData_status, (jint)pData->status);
    LOGI("[internal_getClientDataJObject] OUT - return %p", jClientData);
    return jClientData;
}

static void
internal_onWebServicesRegistryEvent(eAstroWebServicesRegistryEvent event, astroWebServicesClientHandle handle, sAstroWebServicesClientData *pData) {
    LOGI("[internal_onWebServicesRegistryEvent] event=%d, handle=%lu, pData=%p", event, handle, pData);
    if (g_IGingaWebServicesCb_class && g_IGingaWebServicesCb_instance) {
        LOGI("[internal_onWebServicesRegistryEvent] TODO - Invoke event back to Java here");
        // TODO Método para transformar pData em ApplicatonData.java
        // (Vai ter que ser no mko_native_wrapper, pq vou precisar da g_jvm...)
        // Será mesmo? Posso pegar a g_jvm
        JNIEnv * env = 0;
        int isAttached = 0;
        int status = 0;
        if (!g_jvm) {
            LOGE("[internal_onWebServicesRegistryEvent] !g_jvm - exit");
            return;
        }
        status = g_jvm->GetEnv((void **)&env, JNI_VERSION_1_6);
        if (status == JNI_EDETACHED) { // need to attach thread
            JavaVMAttachArgs attachArgs = {
                    JNI_VERSION_1_6,
                    "onAppListEvt",            // thread name is trunked to 16 bytes
                    0
            };
            jint r = g_jvm->AttachCurrentThread(&env, &attachArgs);
            if (r != 0) {
                LOGE("[internal_onWebServicesRegistryEvent] AttachCurrentThread failed - exit");
                return;
            }
            isAttached = 1;
        } else if (status < JNI_OK) {
            LOGE("jvm erro %d to bind env ", status);
            return;
        }

       // TODO MIOLO AQUI
        jobject jClientData = nullptr;
        jClientData = internal_getClientDataJObject(env, handle, pData);

        LOGI("[internal_onWebServicesRegistryEvent] Java AppData object = %p; Call Java method", jClientData);
        // TODO Pass handle too?
        env->CallVoidMethod(g_IGingaWebServicesCb_instance, g_IGingaWebServicesCb_notify, (jint)event, /*(jint)handle,*/ jClientData);
        LOGI("[internal_onWebServicesRegistryEvent] Java method returned");

        if (isAttached) { // need to detach thread
            g_jvm->DetachCurrentThread();
        }
    } else {
        LOGE("[internal_onApplicationListEvent] No one to invoke");
    }
}

extern "C" void AstroWebServices_priv_initJniBindings(JNIEnv *env) {
    LOGI("[JNI] [AstroWebServices_priv_initJniBindings] IN");
    int status = env->GetJavaVM(&g_jvm);
    if(status != 0) {
        LOGE("[%s] Couldn't get JavaVM pointer", __FUNCTION__);
        return;
    }
    jclass local_class = env->FindClass("com/mirakulo/astrotv/IGingaWebServicesRegistryEventCallback");
    if (!local_class) {
        LOGE("[%s] Couldn't find IGingaWebServicesRegistryEventCallback", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_IGingaWebServicesCb_class = (jclass)env->NewGlobalRef(local_class);
    if (!g_IGingaWebServicesCb_class) {
        LOGE("[%s] Couldn't allocated IGingaWebServicesRegistryEventCallback", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_IGingaWebServicesCb_notify = (jmethodID)env->GetMethodID(g_IGingaWebServicesCb_class, "callback", "(ILcom/mirakulo/astrotv/GingaWebServicesClientData;)V");

    local_class = env->FindClass("com/mirakulo/astrotv/GingaWebServicesClientData");
    if (!local_class) {
        LOGE("[%s] Couldn't find GingaWebServicesClientData", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_class = (jclass)env->NewGlobalRef(local_class);
    if (!g_WebServicesClientData_class) {
        LOGE("[%s] Couldn't allocated GingaWebServicesClientData", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_constructor = (jmethodID)env->GetMethodID(g_WebServicesClientData_class, "<init>", "()V");
    if (!g_WebServicesClientData_constructor) {
        LOGE("[%s] Couldn't get constructor class", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_handle = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "handle", "I");
    g_WebServicesClientData_name = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "name", "Ljava/lang/String;");
    g_WebServicesClientData_status = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "status", "I");
    if (!g_WebServicesClientData_handle || !g_WebServicesClientData_name || !g_WebServicesClientData_status) {
        LOGE("[%s] Couldn't find local fields", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    LOGI("[JNI] [AstroWebServices_priv_initJniBindings] OUT");
}

extern "C"
JNIEXPORT jint JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1setEventCallback(
        JNIEnv *env, jclass clazz, jobject callback) {
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] IN");
    int status = env->GetJavaVM(&g_jvm);
    if(status != 0) {
        LOGE("[MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] Couldn't get JavaVM pointer");
        return (jint)(eAstroWebServicesError_UNKNOWN);
    }
    if(g_IGingaWebServicesCb_instance != NULL) env->DeleteGlobalRef(g_IGingaWebServicesCb_instance);
    g_IGingaWebServicesCb_instance = callback == NULL ? NULL : env->NewGlobalRef(callback);
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] g_IGingaWebServicesCb_instance=%p", g_IGingaWebServicesCb_instance);
    eAstroWebServicesError err = astroWebServicesRegistry_setEventCallback(callback == NULL ? NULL : &internal_onWebServicesRegistryEvent);
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] OUT - err = %d", err);
    return (jint)err;
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1getEntries(JNIEnv *env,
                                                                                     jclass clazz) {
    // TODO Build and cache an internal data structure?
    _u32 numEntries = 0;
    if (!g_WebServicesClientData_class) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Must call gingaWebServicesRegistry_1setEventCallback first!");
        return NULL;
    }
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Calling astroWebServicesRegistry_getNumOfEntries");
    eAstroWebServicesError errCode = astroWebServicesRegistry_getNumOfEntries(&numEntries);
    if (errCode != eAstroWebServicesError_OK) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Error calling astroWebServicesRegistry_getNumOfEntries [%d]", errCode);
        return env->NewObjectArray(0, g_WebServicesClientData_class, NULL); // EMPTY ARRAY
    }
    if (numEntries == 0) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Empty list");
        return env->NewObjectArray(0, g_WebServicesClientData_class, NULL); // EMPTY ARRAY
    }
    astroWebServicesClientData *cArray = new astroWebServicesClientData[numEntries];
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Calling astroWebServicesRegistry_getEntries");
    errCode = astroWebServicesRegistry_getEntries(cArray, numEntries);
    if (errCode != eAstroWebServicesError_OK) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Error calling astroWebServicesRegistry_getEntries [%d]", errCode);
        delete [] cArray;
        return env->NewObjectArray(0, g_WebServicesClientData_class, NULL); // EMPTY ARRAY
    }
    jobjectArray out_array = env->NewObjectArray(numEntries, g_WebServicesClientData_class, NULL);
    jobject elem;
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Traversing and writing Java array");
    for (int i = 0; i < numEntries; i++) {
        elem = internal_getClientDataJObject(env, cArray[i].handle, &cArray[i]);
        if (elem == NULL)
          LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] calling internal_getClientDataJObject return NULL");
        else
          env->SetObjectArrayElement(out_array, i, elem);
    }
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Java array traversed and written");

    delete [] cArray;
    return out_array;
}

extern "C"
JNIEXPORT jint JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1removeEntry(JNIEnv *env,
                                                                                      jclass clazz,
                                                                                      jint handle) {
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_removeEntry] IN");
    eAstroWebServicesError  err = astroWebServicesRegistry_removeEntry(handle);
    // TODO Remove from the internal data structure built in getEntries?
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_removeEntry] OUT - err = %d", err);
    return (jint)err;
}

extern "C"
JNIEXPORT jint JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1updateEntry(JNIEnv *env,
                                                                                      jclass clazz,
                                                                                      jint handle,
                                                                                      jint status) {
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_updateEntry] IN");
    eAstroWebServicesError  err = astroWebServicesRegistry_updateEntry(handle, (astroWebServicesClientStatus)status);
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_updateEntry] OUT - err = %d", err);
    return (jint)err;
}

## USER
env->DeleteLocalRef(jName)

as referencias criadas localmente precisão ser liberadas, isso nao eh automatico?
pensei que apenas as ref globais deveriam ser liberadas.

## USER
5) `FindClass` em thread nativa

todas as inicializacoes do jni no "C" sao feitas dentro desse metodo:

JNIEXPORT jint JNICALL
JNI_OnLoad (JavaVM *jvm, void *reserved)
{
    LOGI("[JNI_OnLoad] BEGIN");
    setAndroidJavaVM(jvm);
    LOGI("[JNI_OnLoad] END");
    return JNI_VERSION_1_6;
}

## USER
fiz as correcoes indicadas.
confira se faltou algo:

#include <jni.h>

#include <AstroWebServices.h>
#include <android/log.h>

#define  LOG_TAG    "MIRAKULO"
#if 1 /* 1 to enable logs */
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#else
#define LOGI(...)
#define LOGE(...)   __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#endif

// instance of IGingaWebServicesCallback registered via
// MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback()
static JavaVM *g_jvm = NULL;

static jclass g_IGingaWebServicesCb_class = NULL;
static jobject g_IGingaWebServicesCb_instance = NULL;
static jmethodID g_IGingaWebServicesCb_notify = NULL;

static jclass g_WebServicesClientData_class;
static jmethodID g_WebServicesClientData_constructor;
static jfieldID g_WebServicesClientData_handle;
static jfieldID g_WebServicesClientData_name;
static jfieldID g_WebServicesClientData_status;

static void internal_releaseJniBindings(JNIEnv* env) {
    if (g_IGingaWebServicesCb_instance) { env->DeleteGlobalRef(g_IGingaWebServicesCb_instance); g_IGingaWebServicesCb_instance = NULL; }
    if (g_IGingaWebServicesCb_class)    { env->DeleteGlobalRef(g_IGingaWebServicesCb_class);    g_IGingaWebServicesCb_class = NULL; }
    if (g_WebServicesClientData_class)  { env->DeleteGlobalRef(g_WebServicesClientData_class);  g_WebServicesClientData_class = NULL; }

    g_IGingaWebServicesCb_notify = NULL;
    g_WebServicesClientData_constructor = NULL;
    g_WebServicesClientData_handle = NULL;
    g_WebServicesClientData_name = NULL;
    g_WebServicesClientData_status = NULL;
}

static jobject internal_getClientDataJObject(JNIEnv *env, astroWebServicesClientHandle handle,
                                             sAstroWebServicesClientData *pData) {
    LOGI("[internal_getClientDataJObject] IN - handle=%d, pData=%p", (int)handle, pData);
    if (pData == NULL) {
        LOGE("[internal_getClientDataJObject] data is NULL");
        return NULL;
    };
    jobject jClientData = env->NewObject(g_WebServicesClientData_class, g_WebServicesClientData_constructor);
    env->SetIntField(jClientData, g_WebServicesClientData_handle, (jint)pData->handle);
    jstring jName = env->NewStringUTF(pData->name);
    env->SetObjectField(jClientData, g_WebServicesClientData_name, jName);
    env->DeleteLocalRef(jName); //nao eh obrigatorio, mas em callback recorrente isso vai estourar a tabela de local refs.
    env->SetIntField(jClientData, g_WebServicesClientData_status, (jint)pData->status);
    LOGI("[internal_getClientDataJObject] OUT - return %p", jClientData);
    return jClientData;
}

static void
internal_onWebServicesRegistryEvent(eAstroWebServicesRegistryEvent event, astroWebServicesClientHandle handle, sAstroWebServicesClientData *pData) {
    LOGI("[internal_onWebServicesRegistryEvent] event=%d, handle=%lu, pData=%p", event, handle, pData);
    if (g_IGingaWebServicesCb_class && g_IGingaWebServicesCb_instance) {
        LOGI("[internal_onWebServicesRegistryEvent] TODO - Invoke event back to Java here");
        // TODO Método para transformar pData em ApplicatonData.java
        // (Vai ter que ser no mko_native_wrapper, pq vou precisar da g_jvm...)
        // Será mesmo? Posso pegar a g_jvm
        JNIEnv * env = 0;
        int isAttached = 0;
        int status = 0;
        if (!g_jvm) {
            LOGE("[internal_onWebServicesRegistryEvent] !g_jvm - exit");
            return;
        }
        status = g_jvm->GetEnv((void **)&env, JNI_VERSION_1_6);
        if (status == JNI_EDETACHED) { // need to attach thread
            JavaVMAttachArgs attachArgs = {
                    JNI_VERSION_1_6,
                    "onAppListEvt",            // thread name is trunked to 16 bytes
                    0
            };
            jint r = g_jvm->AttachCurrentThread(&env, &attachArgs);
            if (r != 0) {
                LOGE("[internal_onWebServicesRegistryEvent] AttachCurrentThread failed - exit");
                return;
            }
            isAttached = 1;
        } else if (status < JNI_OK) {
            LOGE("[internal_onWebServicesRegistryEvent] jvm erro %d to bind env ", status);
            return;
        }

       // TODO MIOLO AQUI
        jobject jClientData = nullptr;
        jClientData = internal_getClientDataJObject(env, handle, pData);

        LOGI("[internal_onWebServicesRegistryEvent] Java AppData object = %p; Call Java method", jClientData);
        // TODO Pass handle too?
        env->CallVoidMethod(g_IGingaWebServicesCb_instance, g_IGingaWebServicesCb_notify, (jint)event, /*(jint)handle,*/ jClientData);
        if (env->ExceptionCheck()) {
            LOGE("[internal_onWebServicesRegistryEvent] error on call notify event");
            env->ExceptionClear();
        }
        if (jClientData) env->DeleteLocalRef(jClientData);  //nao eh obrigatorio, mas em callback recorrente isso vai estourar a tabela de local refs.

        LOGI("[internal_onWebServicesRegistryEvent] Java method returned");

        if (isAttached) { // need to detach thread
            g_jvm->DetachCurrentThread();
        }
    } else {
        LOGE("[internal_onWebServicesRegistryEvent] No one to invoke");
    }
}

extern "C" void AstroWebServices_priv_initJniBindings(JNIEnv *env) {
    LOGI("[JNI] [AstroWebServices_priv_initJniBindings] IN");
    int status = env->GetJavaVM(&g_jvm);
    if(status != 0) {
        LOGE("[%s] Couldn't get JavaVM pointer", __FUNCTION__);
        return;
    }
    jclass local_class = env->FindClass("com/mirakulo/astrotv/IGingaWebServicesRegistryEventCallback");
    if (!local_class) {
        LOGE("[%s] Couldn't find IGingaWebServicesRegistryEventCallback", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_IGingaWebServicesCb_class = (jclass)env->NewGlobalRef(local_class);
    if (!g_IGingaWebServicesCb_class) {
        LOGE("[%s] Couldn't allocated IGingaWebServicesRegistryEventCallback", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_IGingaWebServicesCb_notify = (jmethodID)env->GetMethodID(g_IGingaWebServicesCb_class, "callback", "(ILcom/mirakulo/astrotv/GingaWebServicesClientData;)V");

    local_class = env->FindClass("com/mirakulo/astrotv/GingaWebServicesClientData");
    if (!local_class) {
        LOGE("[%s] Couldn't find GingaWebServicesClientData", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_class = (jclass)env->NewGlobalRef(local_class);
    if (!g_WebServicesClientData_class) {
        LOGE("[%s] Couldn't allocated GingaWebServicesClientData", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_constructor = (jmethodID)env->GetMethodID(g_WebServicesClientData_class, "<init>", "()V");
    if (!g_WebServicesClientData_constructor) {
        LOGE("[%s] Couldn't get constructor class", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    g_WebServicesClientData_handle = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "handle", "I");
    g_WebServicesClientData_name = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "name", "Ljava/lang/String;");
    g_WebServicesClientData_status = (jfieldID)env->GetFieldID(g_WebServicesClientData_class, "status", "I");
    if (!g_WebServicesClientData_handle || !g_WebServicesClientData_name || !g_WebServicesClientData_status) {
        LOGE("[%s] Couldn't find local fields", __FUNCTION__);
        env->ExceptionClear();
        return;
    }
    LOGI("[JNI] [AstroWebServices_priv_initJniBindings] OUT");
}

extern "C"
JNIEXPORT jint JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1setEventCallback(
        JNIEnv *env, jclass clazz, jobject callback) {
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] IN");
    if (!g_jvm) {
        LOGE("[gingaWebServicesRegistry_setEventCallback] !g_jvm - exit");
        return;
    }

    //TODO: pode ter o risco de concorrencia nessa troca de callback
    if(g_IGingaWebServicesCb_instance != NULL) env->DeleteGlobalRef(g_IGingaWebServicesCb_instance);
    g_IGingaWebServicesCb_instance = callback == NULL ? NULL : env->NewGlobalRef(callback);
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] g_IGingaWebServicesCb_instance=%p", g_IGingaWebServicesCb_instance);
    eAstroWebServicesError err = astroWebServicesRegistry_setEventCallback(callback == NULL ? NULL : &internal_onWebServicesRegistryEvent);
    if (err != eAstroWebServicesError_OK && g_IGingaWebServicesCb_instance) {
        //nao mantem instancia alocada em caso de erro
        env->DeleteGlobalRef(g_IGingaWebServicesCb_instance);
        g_IGingaWebServicesCb_instance = NULL;
    }
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_setEventCallback] OUT - err = %d", err);
    return (jint)err;
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1getEntries(JNIEnv *env,
                                                                                     jclass clazz) {
    // TODO Build and cache an internal data structure?
    _u32 numEntries = 0;
    if (!g_WebServicesClientData_class) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Must call gingaWebServicesRegistry_1setEventCallback first!");
        return NULL;
    }
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Calling astroWebServicesRegistry_getNumOfEntries");
    eAstroWebServicesError errCode = astroWebServicesRegistry_getNumOfEntries(&numEntries);
    if (errCode != eAstroWebServicesError_OK) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Error calling astroWebServicesRegistry_getNumOfEntries [%d]", errCode);
        return env->NewObjectArray(0, g_WebServicesClientData_class, NULL); // EMPTY ARRAY
    }
    if (numEntries == 0) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Empty list");
        return env->NewObjectArray(0, g_WebServicesClientData_class, NULL); // EMPTY ARRAY
    }
    astroWebServicesClientData *cArray = new astroWebServicesClientData[numEntries];
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Calling astroWebServicesRegistry_getEntries");
    errCode = astroWebServicesRegistry_getEntries(cArray, numEntries);
    if (errCode != eAstroWebServicesError_OK) {
        LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Error calling astroWebServicesRegistry_getEntries [%d]", errCode);
        delete [] cArray;
        return env->NewObjectArray(0, g_WebServicesClientData_class, NULL); // EMPTY ARRAY
    }
    jobjectArray out_array = env->NewObjectArray(numEntries, g_WebServicesClientData_class, NULL);
    jobject elem;
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Traversing and writing Java array");
    for (int i = 0; i < numEntries; i++) {
        elem = internal_getClientDataJObject(env, cArray[i].handle, &cArray[i]);
        if (elem == NULL)
          LOGE("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] calling internal_getClientDataJObject return NULL");
        else {
          env->SetObjectArrayElement(out_array, i, elem);
          env->DeleteLocalRef(elem);
        }
    }
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_getEntries] Java array traversed and written");

    delete [] cArray;
    return out_array;
}

extern "C"
JNIEXPORT jint JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1removeEntry(JNIEnv *env,
                                                                                      jclass clazz,
                                                                                      jint handle) {
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_removeEntry] IN");
    eAstroWebServicesError  err = astroWebServicesRegistry_removeEntry(handle);
    // TODO Remove from the internal data structure built in getEntries?
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_removeEntry] OUT - err = %d", err);
    return (jint)err;
}

extern "C"
JNIEXPORT jint JNICALL
Java_com_mirakulo_astrotv_MirakuloNativeWrapper_gingaWebServicesRegistry_1updateEntry(JNIEnv *env,
                                                                                      jclass clazz,
                                                                                      jint handle,
                                                                                      jint status) {
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_updateEntry] IN");
    eAstroWebServicesError  err = astroWebServicesRegistry_updateEntry(handle, (astroWebServicesClientStatus)status);
    LOGI("[JNI] [MirakuloNativeWrapper.gingaWebServicesRegistry_updateEntry] OUT - err = %d", err);
    return (jint)err;
}

## USER
perfeito.
ultima duvida sobre esta parte.
hj quando eu aloco o construtor com a classe errada, aparentemente esta funcionando. o construtor dessa classe nao faz nada

    local_class = env->FindClass("com/mirakulo/astrotv/GingaWebServicesClientData");
    g_WebServicesClientData_class = (jclass)env->NewGlobalRef(local_class);
    g_WebServicesClientData_constructor = (jmethodID)env->GetMethodID(g_IGingaWebServicesCb_class, "<init>", "()V");

## USER
sobre o ExceptionCheck(), faz diferenca de usar sempre ou nas partes q o "if" compara com null, tb poderia ser substituido?

## USER
e sobre o ExceptionDescribe, eu estou usando a macro LOGE pra registrar uma linha de erro, e nao o trace da exception, pois isso ja eh suficiente pra o meu debug

## USER
ao buildar os fontes em "C/C++" estou tomando um erro:

/w/native/products/atv/AstroWebServices_JNI.cc:30:5: error: use of undeclared identifier 'internal_releaseJniBindings'
internal_releaseJniBindings(env);
^

o fonte ".cc" esta assim:

...
extern "C" void AstroWebServices_priv_releaseJniBindings(JNIEnv* env) {
    internal_releaseJniBindings(env);
}

static void internal_releaseJniBindings(JNIEnv* env) {
    if (g_IGingaWebServicesCb_instance) { env->DeleteGlobalRef(g_IGingaWebServicesCb_instance); g_IGingaWebServicesCb_instance = NULL; }
    if (g_IGingaWebServicesCb_class)    { env->DeleteGlobalRef(g_IGingaWebServicesCb_class);    g_IGingaWebServicesCb_class = NULL; }
    if (g_WebServicesClientData_class)  { env->DeleteGlobalRef(g_WebServicesClientData_class);  g_WebServicesClientData_class = NULL; }

    g_IGingaWebServicesCb_notify = NULL;
    g_WebServicesClientData_constructor = NULL;
    g_WebServicesClientData_handle = NULL;
    g_WebServicesClientData_name = NULL;
    g_WebServicesClientData_status = NULL;
}
...

## ASSISTANT
Esse erro é só ordem de declaração em C++: você está chamando internal_releaseJniBindings(env) antes do compilador ter visto a declaração dela.

Como internal_releaseJniBindings é static, ela tem linkage interno e precisa de um protótipo antes do uso, ou então você move a definição para cima.

Correção 1 (recomendada): declare o protótipo antes

Coloque no topo do arquivo (antes de AstroWebServices_priv_releaseJniBindings):

cpp
Copy code
static void internal_releaseJniBindings(JNIEnv* env);


Depois seu código compila normalmente:

cpp
Copy code
static void internal_releaseJniBindings(JNIEnv* env);

extern "C" void AstroWebServices_priv_releaseJniBindings(JNIEnv* env) {
    internal_releaseJniBindings(env);
}

static void internal_releaseJniBindings(JNIEnv* env) {
   ...
}

Correção 2: mover a função static para cima

Defina internal_releaseJniBindings antes do wrapper extern "C".

Observação

Se você pretende expor AstroWebServices_priv_releaseJniBindings para outros TUs, mantenha ele não-static (como está) e garanta que existe um header com a declaração extern "C" correspondente para evitar name mangling ao linkar de C.

